# PROD-27785 - Integration PData "Revue des Index" dans la RCL

## Contexte

### Probleme initial
Les Regularisations de Charges Locatives (RCL) ne prenaient pas en compte les donnees forcees manuellement via le script PData "updateAllocationKeyRevueIndex". Ce script permet de creer des cles de repartition INDEX avec des consommations manuelles (fractionalShares) pour les cas ou les donnees d'historique de compteurs sont absentes ou incorrectes.

### Symptomes
1. **Total building incorrect** : Le shareBase utilise provenait de la DB au lieu des valeurs PData
2. **Consommations individuelles incorrectes** : Les fractionalShares PData n'etaient pas utilises
3. **Probleme de filtrage** : Toutes les unites du building etaient comptees (y compris les unites vides)

---

## Architecture avec Routing Legacy/Normal

### Principe

Au lieu de modifier le code existant pour supporter les cles PData, nous avons mis en place un **systeme de routing** qui detecte la presence de cles PData et decide quel code executer :

- **Si cles PData "Revue des Index" detectees** -> Utilisation du code legacy avec support PData
- **Sinon** -> Utilisation du code normal (master)

### Structure des fichiers

```
src/routes/accounting/rentalManagement/expenseRegularization/processes/
├── createExpenseRegularization.process.ts            # Code normal (master) avec routing
├── fluid.process.ts                                  # Code normal (master)
├── computations/
│   └── expenseType.computation.ts                    # Code normal (master)
│
└── legacyAllocationKeyWithDataLost/                  # Code legacy isole
    ├── createExpenseRegularization.process.ts        # Version legacy avec PData
    ├── fluid.process.ts                              # Version legacy avec PData
    └── computations/
        └── expenseType.computation.ts                # Version legacy avec PData
```

### Fonction de detection

```typescript
async function hasPdataRevueIndexKeys(
  accountingPeriodId: string,
  buildingId: string,
): Promise<boolean> {
  const pdataAllocationKeys = await AllocationKeyModel.find({
    building: new Types.ObjectId(buildingId),
    accountingPeriod: new Types.ObjectId(accountingPeriodId),
    genericTitle: { $regex: /- Revue des Index$/ },
  })
    .select("_id")
    .limit(1)
    .lean();

  return pdataAllocationKeys.length > 0;
}
```

Cette fonction :
- Recherche les cles avec pattern "- Revue des Index"
- Ne recupere que l'`_id` (optimisation)
- Utilise `limit(1)` car un seul suffit pour decider
- Retourne `true` si au moins une cle PData existe

### Point de routing dans `createExpenseRegularization`

```typescript
export async function createExpenseRegularization(accountingPeriodId: string) {
  // ... verifications initiales ...

  const accountingPeriod = await getOneAccountingPeriod(accountingPeriodId);

  // Point de routing PROD-27785
  const shouldUseLegacyCode = await hasPdataRevueIndexKeys(
    accountingPeriodId,
    accountingPeriod.building,
  );

  if (shouldUseLegacyCode) {
    logger.info(
      "[PROD-27785] PData 'Revue des Index' allocation keys detected. Using legacy code with PData support.",
      {
        accountingPeriodId,
        building: accountingPeriod.building,
      },
    );
    return createExpenseRegularizationWithPdataAllocationKeys(accountingPeriodId);
  }

  logger.info(
    "[PROD-27785] No PData 'Revue des Index' allocation keys found. Using normal code flow.",
    {
      accountingPeriodId,
      building: accountingPeriod.building,
    },
  );

  // ... suite du code normal (master) ...
}
```

### Avantages de cette architecture

| Avantage | Description |
|----------|-------------|
| **Isolation du code PData** | Le code normal (master) n'est pas modifie, aucun risque de regression |
| **Facilite de maintenance** | Modifications PData isolees dans un dossier dedie |
| **Transition progressive** | Possibilite de supprimer facilement le code legacy plus tard |
| **Logs explicites** | Chaque RCL logge quel code est utilise |

---

## Solution implementee (Code Legacy)

### 1. Nouvelle fonction `mergeWithPdataAllocationkey`

**Fichier** : `createExpenseRegularization.process.ts`

**Role** : Fusionne les donnees des cles "Revue des Index" avec les expenses de la periode comptable.

```typescript
async function mergeWithPdataAllocationkey(
  expenses: RegularizationPeriodExpense[],
  accountingPeriod: AccountingPeriodForRegularizationType,
): Promise<RegularizationPeriodExpense[]>
```

**Logique** :
1. Recherche les cles avec `genericTitle` finissant par `"- Revue des Index"`
2. Matche par numero de cle (`number`)
3. Pour chaque unit presente dans le PData :
   - Met a jour `fractionalShares` avec la valeur PData
   - **Vide le tableau `fluids`** pour forcer l'utilisation des fractionalShares
4. Garde toutes les autres units de l'expense telles quelles

**Point critique** :
```typescript
return {
  ...expenseUnit,
  fractionalShares: pdataUnit.fractionalShares,
  fluids: [], // CRITIQUE : Force l'utilisation des fractionalShares
};
```

### 2. Modification de `computeBuildingFluidExpenses`

**Fichier** : `fluid.process.ts`

**Changement** : Utilisation du `shareBase` depuis les expenses merges au lieu de recalculer.

**Avant** :
```typescript
sumFluidsOfOthersAllocationKeyIndex = buildingIndexAllocationKeys.reduce((accObj, allocationKey) => {
  return {
    ...accObj,
    [allocationKey.number]: sumFluidsByAllocationKeyNumber(
      allocationKey.units,  // Recalcule depuis la DB
      accountingPeriod,
    ),
  };
}, {});
```

**Apres** :
```typescript
// Creer un map des shareBase depuis les expenses (incluant les donnees PData mergees)
const shareBaseFromExpenses = new Map<string, number>();
othersAllocationKeyIndex.forEach((key) => {
  if (key.shareBase !== undefined) {
    shareBaseFromExpenses.set(key.number, key.shareBase);
  }
});

sumFluidsOfOthersAllocationKeyIndex = buildingIndexAllocationKeys.reduce((accObj, allocationKey) => {
  const shareBaseFromExpense = shareBaseFromExpenses.get(allocationKey.number);

  const shareBase = shareBaseFromExpense ?? sumFluidsByAllocationKeyNumber(
    allocationKey.units,
    accountingPeriod,
  );

  return {
    ...accObj,
    [allocationKey.number]: shareBase, // Utilise le shareBase PData si disponible
  };
}, {});
```

### 3. Support des `fractionalShares` dans `sumFluidsByAllocationKeyNumber`

**Fichier** : `fluid.process.ts`

**Ajout** : Gestion des units sans fluids mais avec fractionalShares.

```typescript
function sumFluidsByAllocationKeyNumber(
  units: UnitsType[],
  accountingPeriod: AccountingPeriodForRegularizationType,
) {
  return units.reduce((acc, unit) => {
    // Cas 1 : Unit avec fluids (comportement normal)
    if (unit.fluids?.length) {
      return acc + sumFluidsByUnit(unit.fluids, accountingPeriod);
    }

    // Cas 2 : Unit sans fluids mais avec fractionalShares (cles PData)
    if (unit.fractionalShares !== undefined && Number.isFinite(unit.fractionalShares)) {
      return acc + unit.fractionalShares;
    }

    return acc;
  }, 0);
}
```

### 4. Generation des lignes d'index pour les cles PData

**Fichier** : `expenseType.computation.ts`

**Ajout** : Creation de lignes d'index pour les units sans fluids.

```typescript
const getIndexFluids = (...) => {
  if (!expensesPerExpenseType[0].allocationKey.accountingPeriod) {
    return expensesPerExpenseType[0].allocationKey?.units?.flatMap((unit) => {
      // Cas 1 : Unit avec fluids
      if (unit.fluids?.length) {
        return unit.fluids.map((fluid) =>
          __computeUnitFluidIndex(accountingPeriod, lease, fluid, unit, leaveMeasurements)
        );
      }

      // Cas 2 : Unit avec fractionalShares uniquement (PROD-27785)
      if (unit.fractionalShares !== undefined && Number.isFinite(unit.fractionalShares)) {
        return [mapExpenseRegularizationExpenseTypeFluid({
          lease,
          fluid: {
            deviceNumber: "N/A", // Pas de compteur physique
            fractionalShares: unit.fractionalShares,
            oldIndex: undefined,
            newIndex: undefined,
            isPackage: false,
          },
          unit: {
            _id: unit._id.toHexString(),
            fractionalShares: unit.fractionalShares,
          },
        })];
      }

      return [];
    });
  }
  // ...
};
```

**Point important** : `deviceNumber: "N/A"` pour eviter l'erreur de validation `Path 'deviceNumber' is required`.

### 5. Integration dans le flux principal

**Fichier** : `createExpenseRegularization.process.ts`

```typescript
let accountingPeriodExpenses = await __getAccountingPeriodExpenses(accountingPeriod);

// PROD-27785: Override avec les donnees PData "Revue des Index" si elles existent
accountingPeriodExpenses = await mergeWithPdataAllocationkey(
  accountingPeriodExpenses,
  accountingPeriod,
);
```

---

## Flux de donnees

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Recuperation des expenses depuis MongoDB                 │
│    __getAccountingPeriodExpenses()                          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Merge avec les cles PData "Revue des Index"              │
│    mergeWithPdataAllocationkey()                            │
│    - Recupere cles avec genericTitle matching regex         │
│    - Met a jour shareBase et fractionalShares               │
│    - Vide les fluids[] pour forcer l'usage des fractional   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Calcul du total building                                 │
│    computeBuildingFluidExpenses()                           │
│    - Utilise shareBase depuis expenses (pas DB)             │
│    - Pour autres cles: calcul normal depuis fluids          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Generation des lignes d'index par bail                   │
│    getIndexFluids()                                         │
│    - Units avec fluids: calcul normal                       │
│    - Units sans fluids: utilise fractionalShares PData      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Calcul montants par bail                                 │
│    leaseAmount = buildingAmount × (conso_lot / conso_total) │
└─────────────────────────────────────────────────────────────┘
```

---

## Cas d'usage

### Cas 1 : Immeuble avec PData "Revue des Index"

```
1. createExpenseRegularization('period123') appele
2. hasPdataRevueIndexKeys() -> trouve une cle "42 - Revue des Index"
3. Log: "PData 'Revue des Index' allocation keys detected"
4. createExpenseRegularizationWithPdataAllocationKeys() appele
5. RCL creee avec valeurs PData forcees
```

### Cas 2 : Immeuble normal sans PData

```
1. createExpenseRegularization('period456') appele
2. hasPdataRevueIndexKeys() -> aucune cle trouvee
3. Log: "No PData 'Revue des Index' allocation keys found"
4. Suite du code normal (master)
5. RCL creee avec calculs DB normaux
```

---

## Risques d'erreur possibles

### CRITIQUE

#### 1. Collision de numeros de cles
**Risque** : Si une cle "normale" et une cle "Revue des Index" ont le meme numero.

**Symptome** : La cle normale sera ecrasee par les donnees PData.

**Mitigation** :
- Le script PData utilise un pattern specifique : `"${number} - Revue des Index"`
- Le merge cherche uniquement les cles avec `genericTitle` finissant par `"- Revue des Index"`

#### 2. Perte de donnees fluids
**Risque** : Le vidage de `fluids: []` pourrait affecter d'autres parties du code qui s'attendent a avoir des fluids.

**Symptome** : Erreurs dans les calculs downstream ou affichage.

**Mitigation** : Le vidage ne s'applique qu'aux units presentes dans le PData.

#### 3. Validation deviceNumber
**Risque** : Si le modele change et que "N/A" n'est plus accepte.

**Symptome** : `ValidationError: Path 'deviceNumber' is required`

**Mitigation** : Utilisation d'une valeur fixe reconnaissable "N/A".

### MODERE

#### 4. Desynchronisation entre PData et expenses
**Risque** : Si le PData est mis a jour apres la recuperation des expenses.

**Mitigation** : Le merge se fait au moment de la creation de la RCL, donc utilise les donnees a jour.

#### 5. Units presentes dans PData mais pas dans expenses
**Risque** : Le code tente de creer une unit qui n'existe pas.

**Mitigation** : Le merge ne cree PAS de nouvelles units, il met seulement a jour celles existantes.

#### 6. ShareBase incoherent
**Risque** : Le shareBase PData ne correspond pas a la somme des fractionalShares.

**Mitigation** : Le script PData calcule automatiquement le shareBase.

### FAIBLE

#### 7. Performance avec beaucoup de cles PData
**Risque** : Le regex et les maps pourraient ralentir le traitement.

**Mitigation** : Utilisation de Maps pour O(1) lookup.

#### 8. Cles PData non liees a la bonne accountingPeriod
**Risque** : Utilisation de donnees d'une autre periode.

**Mitigation** : Le filtre MongoDB verifie `accountingPeriod._id`.

---

## Plan de tests

### Tests unitaires recommandes

#### Test de `mergeWithPdataAllocationkey`

```typescript
describe('mergeWithPdataAllocationkey', () => {
  it('should merge PData shareBase and fractionalShares', async () => {
    // Given
    const expenses = [createExpense({ number: '836', units: [...] })];
    const pdataKey = createPdataKey({ number: '836', shareBase: 98201, units: [...] });

    // When
    const result = await mergeWithPdataAllocationkey(expenses, accountingPeriod);

    // Then
    expect(result[0].allocationKey.shareBase).toBe(98201);
    expect(result[0].allocationKey.units[0].fractionalShares).toBe(30);
    expect(result[0].allocationKey.units[0].fluids).toEqual([]);
  });

  it('should keep non-PData units unchanged', async () => {
    // Given
    const expenses = [createExpense({ units: [unitA, unitB, unitC] })];
    const pdataKey = createPdataKey({ units: [unitA] }); // Seulement unitA

    // When
    const result = await mergeWithPdataAllocationkey(expenses, accountingPeriod);

    // Then
    expect(result[0].allocationKey.units[1]).toEqual(unitB); // Unchanged
    expect(result[0].allocationKey.units[2]).toEqual(unitC); // Unchanged
  });
});
```

#### Test de routing

```typescript
// Test 1 : Routing vers legacy
// Given: Une periode avec cle PData
const period = { _id: 'xxx', building: 'yyy' };
await AllocationKeyModel.create({
  building: 'yyy',
  accountingPeriod: 'xxx',
  genericTitle: '42 - Revue des Index',
});

// When: Creation RCL
await createExpenseRegularization('xxx');

// Then: Code legacy utilise (verifier logs)
```

```typescript
// Test 2 : Routing vers normal
// Given: Une periode SANS cle PData
const period = { _id: 'xxx', building: 'yyy' };

// When: Creation RCL
await createExpenseRegularization('xxx');

// Then: Code normal utilise (verifier logs)
```

### Tests manuels recommandes (via Prime)

#### Test 1 : Verification visuelle des lignes d'index

1. Creer une cle PData avec 3 units
2. Creer une RCL
3. Ouvrir dans Prime
4. Verifier que :
   - Les lignes d'index s'affichent
   - `deviceNumber` affiche "N/A"
   - Les consommations correspondent aux fractionalShares PData
   - Le total building est correct

#### Test 2 : Coherence des montants

1. Creer cle PData avec shareBase = 100, units = [30, 30, 40]
2. Creer accounting line avec montant 1000EUR
3. Creer RCL
4. Verifier dans Prime :
   - Unit 1 : 1000EUR x (30/100) = 300EUR
   - Unit 2 : 1000EUR x (30/100) = 300EUR
   - Unit 3 : 1000EUR x (40/100) = 400EUR
   - Total : 1000EUR

---

## Migration et suppression future

Lorsque les cles PData ne seront plus utilisees, il suffira de :

1. Supprimer le dossier `processes/legacyAllocationKeyWithDataLost/`
2. Retirer les imports et la fonction `hasPdataRevueIndexKeys` dans `createExpenseRegularization.process.ts`
3. Retirer les logs `[PROD-27785]`
4. Nettoyer les commentaires `// PROD-27785:`

Le code restera alors dans son etat master original.

---

## Checklist de deploiement

### Avant deploiement

- [ ] Tests unitaires passent
- [ ] Tests d'integration passent
- [ ] Test manuel sur environnement de dev
- [ ] Verification que les cles PData existantes sont bien detectees
- [ ] Verification de la non-regression sur cles normales
- [ ] Review du code par un pair
- [ ] Documentation mise a jour

### Apres deploiement

- [ ] Monitoring des logs pour erreurs de validation
- [ ] Verification des RCL creees en production
- [ ] Feedback des utilisateurs sur les montants
- [ ] Monitoring des performances (temps de creation RCL)

---

## Notes de developpement

### Pourquoi vider les fluids ?

Le code original verifie d'abord si `unit.fluids?.length` avant de regarder `unit.fractionalShares`. En vidant les fluids, on force le code a passer dans la branche PData.

### Pourquoi deviceNumber "N/A" ?

Le modele de validation exige un `deviceNumber` de type string. Pour les cles PData qui n'ont pas de compteur physique, on utilise "N/A" comme valeur sentinel.

### Ordre des operations

L'ordre est crucial :
1. D'abord recuperer les expenses
2. Ensuite merger avec PData
3. Enfin calculer les totaux building

Si on inverse, les valeurs PData ne seraient pas prises en compte.

### Alternative consideree et rejetee

**Ajouter `accountingPeriod` aux expenses merges** :
- Probleme : Les expenses passent dans le cas "avec periode" et cherchent `allocationKeyWithMeasurement`
- Les cles PData n'ont pas de readings/measurements
- Resultat : Pas de lignes d'index generees

**Solution retenue** : Vider les fluids sans ajouter accountingPeriod.

---

## References

- **Ticket Jira** : [PROD-27785](https://fonciamillenium.atlassian.net/browse/PROD-27785)
- **Script PData** : `scripts/reusablePdata/updateAllocationKeyRevueIndex/`
- **Documentation connexe** :
  - `PROBLEME_BASES_REPARTITION.md` (Probleme #1 et #2)
  - `FIX_PERIODE_COMPTABLE.md` (Gestion accountingPeriod)
